### 浏览器工作原理

#### 01丨Chrome架构：仅仅打开了1个页面，为什么有4个进程？

##### 进程与线程

进程： 进程就是一个程序的运行实例。启动一个程序的时候，系统会为这个程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样一个环境叫做进程。

进程可以由多个线程构成，可以提高处理性能。线程不能单独存在，必须依附于进程。

线程和进程具有如下4个特点：

1. 进程中任意一线程执行出错，会导致整个进程崩溃。
2. 线程之间共享进程中的数据。
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。
4. 进程之间的内容相互隔离。

##### 早期的单进程浏览器时代

![](C:\Users\Administrator\Desktop\知识积累\picture\单进程浏览器.png)

单进程浏览器：即浏览器的所有功能模块都运行在一个进程里。包括网络、插件、JS运行环境、渲染引擎、页面等模块。

特点：不稳定、不流畅和不安全

##### 多进程浏览器时代

![](C:\Users\Administrator\Desktop\知识积累\picture\多进程浏览器.png)

![](C:\Users\Administrator\Desktop\知识积累\picture\最新的多进程浏览器.png)

包括 1个浏览器主进程、1个网络进程、1个GPU进程、多个渲染进程、多个插件进程。

- **浏览器进程**。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。

- **渲染进程**。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。详见[浏览器渲染过程](https://blog.csdn.net/saucxs/article/details/87869810) *注 css资源  图片资源 js资源是在浏览器主进程中下载的*

  渲染进程包括如下几个线程：

  1、GUI渲染线程

  （1）负责解析HTML文件构建DOM树，解析CSS，结合DOM树渲染成RenderObject树，然后布局和绘制页面

  （2）当RenderObject树需要更新样式属性时，即发生重绘（Repaint）；当RenderObject树中的元素规则尺寸，布局或显示隐藏等发生变化，即发生回流（reflow）。

  2、JS引擎线程

  3、时间出发线程

  4、定时器触发线程

  5、异步Http请求线程

  注：GUI渲染线程与JS引擎线程是相互排斥的，因为JS引擎线程在执行的过程中可能会发生重绘和回流，所以GUI渲染线程执行时候，JS引擎线程会被挂起，等待GUI渲染线程执行完毕之后，JS引擎线程执行时候同理。

- **GPU 进程** 将图块栅格化生成位图

- **网络进程**。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。

- **插件进程**。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

特点：更高的资源占用、更复杂的体系架构

##### 未来的 面向服务的架构

![](C:\Users\Administrator\Desktop\知识积累\picture\面向服务的架构.png)











#### 05丨渲染流程

1. 构建DOM树

   将HTML解析成浏览器能够识别的DOM树

2. 样式计算 CSSOM树

   作用：第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息

   目的：计算DOM树中每个元素的样式

   1. 把CSS文件转换为浏览器能够识别的样式表结构styleSheets
   2. 样式表中的属性值标准化，易于渲染引擎理解
   3. 根据CSS继承和层叠规则，计算DOM树中每个节点的具体样式

3. 布局阶段 布局树

   目的：过滤掉DOM树中不需要显示的元素，计算DOM树中可见元素的位置信息

   1. 创建布局树。根据DOM树和computedStyle生成只包含可见元素的布局树
   2. 布局计算。 计算每个可见节点的位置坐标

4. 分层

   为特定的节点生成专用的图层，进而生成一个图层树

   - 拥有层叠上下文属性的元素会被提升为单独的一层。如z-index:2, position:fixed, filter:blue(5px),opacity:0.5
   - 需要剪裁（clip）的地方也会被创建为图层。overflow:auto

   目的： 为了方便实现复杂的动画效果，如滚动，3D变换，Z轴排序

5. 生成绘制列表

   把每个图层的绘制拆分成很多小的绘制指令，组成待绘制列表

6. 栅格化操作

   实际的绘制操作是由渲染引擎的 合成线程 操作完成的。

   合成线程会将图层划分为图块。然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。

7. 合成和显示

   图块光栅化后，合成线程发出绘制图块命令，提交到浏览器进程，绘制到内存中，显示到屏幕上。

总结：

![](C:\Users\Administrator\Desktop\知识积累\picture\渲染流程.png)

结合上图，一个完整的渲染流程大致可总结为如下：

1. 渲染进程将 HTML 内容转换为能够读懂的**DOM 树**结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的**styleSheets**，计算出 DOM 节点的样式。
3. 创建**布局树**，并计算元素的布局信息。
4. 对布局树进行分层，并生成**分层树**。
5. 为每个图层生成**绘制列表**，并将其提交到合成线程。
6. 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图。
7. 合成线程发送绘制图块命令**DrawQuad**给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息**生成页面**，并**显示**到显示器上。



#### 22 | DOM树：JavaScript是如何影响DOM树构建的？

##### 什么是DOM？

从网络进程传给渲染引擎的HTML文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是DOM。

##### DOM三个作用

1. 页面角度，DOM是生成页面的基础数据结构。
2. JS角度，DOM提供了JS脚本操作的接口，可以对DOM结构访问，从而修改文档的结构、样式和内容。
3. 安全角度，DOM解析阶段将不安全的内容拒之门外。

##### DOM树如何生成？

将网络进程，传到渲染进程的文件字节流数据，通过HTML解析器解析成DOM树。这个过程是边加载边解析的。

具体：

1. 通过分词器将字节流转化为token。

   token分为tagtoken和文本token，tagtoken又分为starttag和endtag。

2. 将token转化为DOM节点，并将DOM节点添加到DOM树中。

3. 将tagtoken按顺序压入到栈中，遇到一对starttag、endtag则出栈，直至栈内容清空，判断DOM结构解析完毕。文本token不入栈。

##### JS和CSS如何影响DOM生成

JS文件在下载和解析的时候，因为可能会修改DOM树结构，所以会暂时挂起渲染引擎解析生成DOM树。这就是JS文件下载阻塞DOM解析。

JS文件也可能操作DOM的CSS样式，所以渲染引擎在遇到JS文件时，会先执行CSS文件下载，解析，再执行JS脚本。这又是一个阻塞DOM解析。

解决措施：

1. Chrome浏览器预解析，如果HTML文件中包含外部的JS文件、CSS文件，提前下载这些文件。
2. 使用CDN加速文件下载速度。
3. 压缩JS文件体积。
4. 如果JS文件中没有操作DOM的相关代码，可通过async或defer将脚本设置为异步加载。



#### 23 |渲染流水线：CSS如何影响首次加载时的白屏时间？

##### 影响页面展示的因素以及优化策略

##### 解析白屏

提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为**解析白屏**，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。

解析白屏阶段的主要任务：

包括了解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作。

其中白屏时间的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。

所以要想缩短白屏时长，可以有以下策略：

- 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
- 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。
- 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。
- 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。