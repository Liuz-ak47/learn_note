### 浏览器工作原理

#### 01丨Chrome架构：仅仅打开了1个页面，为什么有4个进程？

##### 进程与线程

进程： 进程就是一个程序的运行实例。启动一个程序的时候，系统会为这个程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样一个环境叫做进程。

进程可以由多个线程构成，可以提高处理性能。线程不能单独存在，必须依附于进程。

线程和进程具有如下4个特点：

1. 进程中任意一线程执行出错，会导致整个进程崩溃。
2. 线程之间共享进程中的数据。
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。
4. 进程之间的内容相互隔离。

##### 早期的单进程浏览器时代

![](picture\单进程浏览器.png)

单进程浏览器：即浏览器的所有功能模块都运行在一个进程里。包括网络、插件、JS运行环境、渲染引擎、页面等模块。

特点：不稳定、不流畅和不安全

##### 多进程浏览器时代

![](picture\多进程浏览器.png)

![](picture\最新的多进程浏览器.png)

包括 1个浏览器主进程、1个网络进程、1个GPU进程、多个渲染进程、多个插件进程。

- **浏览器进程**。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。

- **渲染进程**。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。详见[浏览器渲染过程](https://blog.csdn.net/saucxs/article/details/87869810) *注 css资源  图片资源 js资源是在浏览器主进程中下载的*

  渲染进程包括如下几个线程：

  1、GUI渲染线程

  （1）负责解析HTML文件构建DOM树，解析CSS，结合DOM树渲染成RenderObject树，然后布局和绘制页面

  （2）当RenderObject树需要更新样式属性时，即发生重绘（Repaint）；当RenderObject树中的元素规则尺寸，布局或显示隐藏等发生变化，即发生回流（reflow）。

  2、JS引擎线程

  3、时间出发线程

  4、定时器触发线程

  5、异步Http请求线程

  注：GUI渲染线程与JS引擎线程是相互排斥的，因为JS引擎线程在执行的过程中可能会发生重绘和回流，所以GUI渲染线程执行时候，JS引擎线程会被挂起，等待GUI渲染线程执行完毕之后，JS引擎线程执行时候同理。

- **GPU 进程** 将图块栅格化生成位图

- **网络进程**。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。

- **插件进程**。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

特点：更高的资源占用、更复杂的体系架构

##### 未来的 面向服务的架构

![](picture\面向服务的架构.png)











#### 05丨渲染流程

1. 构建DOM树

   将HTML解析成浏览器能够识别的DOM树

2. 样式计算 CSSOM树

   作用：第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息

   目的：计算DOM树中每个元素的样式

   1. 把CSS文件转换为浏览器能够识别的样式表结构styleSheets
   2. 样式表中的属性值标准化，易于渲染引擎理解
   3. 根据CSS继承和层叠规则，计算DOM树中每个节点的具体样式

3. 布局阶段 布局树

   目的：过滤掉DOM树中不需要显示的元素，计算DOM树中可见元素的位置信息

   1. 创建布局树。根据DOM树和computedStyle生成只包含可见元素的布局树
   2. 布局计算。 计算每个可见节点的位置坐标

4. 分层

   为特定的节点生成专用的图层，进而生成一个图层树

   - 拥有层叠上下文属性的元素会被提升为单独的一层。如z-index:2, position:fixed, filter:blue(5px),opacity:0.5
   - 需要剪裁（clip）的地方也会被创建为图层。overflow:auto

   目的： 为了方便实现复杂的动画效果，如滚动，3D变换，Z轴排序

5. 生成绘制列表

   把每个图层的绘制拆分成很多小的绘制指令，组成待绘制列表

6. 栅格化操作

   实际的绘制操作是由渲染引擎的 合成线程 操作完成的。

   合成线程会将图层划分为图块。然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。

7. 合成和显示

   图块光栅化后，合成线程发出绘制图块命令，提交到浏览器进程，绘制到内存中，显示到屏幕上。

总结：

![](picture\渲染流程.png)

结合上图，一个完整的渲染流程大致可总结为如下：

1. 渲染进程将 HTML 内容转换为能够读懂的**DOM 树**结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的**styleSheets**，计算出 DOM 节点的样式。
3. 创建**布局树**，并计算元素的布局信息。
4. 对布局树进行分层，并生成**分层树**。
5. 为每个图层生成**绘制列表**，并将其提交到合成线程。
6. 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图。
7. 合成线程发送绘制图块命令**DrawQuad**给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息**生成页面**，并**显示**到显示器上。



#### 07 | 变量提升：JavaScript代码是按顺序执行的吗？

![](\picture\变量环境对象.png)

**所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined**

```javascript
showName()
console.log(myname)
var myname = '极客时间'
function showName() {
    console.log('函数 showName 被执行');
}

//结果是
'函数 showName 被执行'   //因为function showName 这是一个函数声名，整体都会提前。注意function(){}这个不是函数声名。
undefined	// var myname属于变量声名，但是赋值操作没有提升。
```

**实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中**。

**编译**完成之后，才会进入**执行**阶段。

输入一段代码，经过**编译**后，会生成两部分内容：**执行上下文（Execution context）和 可执行代码**。

**执行上下文是 JavaScript 执行一段代码时的运行环境**，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。在执行上下文中存在一个**变量环境的对象**（Viriable Environment），该对象中保存了变量提升的内容

变量环境对象：编译阶段变量提升的内容

```javascript
VariableEnvironment:
     myname -> undefined, 
     showName ->function : {console.log(myname)
```

JavaScript 引擎会把声明以外的代码编译为字节码



**一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数**。





#### 08 | 调用栈：为什么JavaScript代码会出现栈溢出？

执行代码执行过程中，遇到调用函数，会为该函数创建 函数执行上下文和执行代码

**调用栈是 JavaScript 引擎追踪函数执行的一个机制**，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。

JavaScript 引擎是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为**执行上下文栈**，又称**调用栈**。当遇到调用函数时，会将该函数的执行上下文压入栈中，执行函数的执行代码，如此直到栈空

所以，调用栈是一种用来管理执行上下文的数据结构



#### 09 | 块级作用域：var缺陷以及为什么要引入let和const？

ES6之前，只存在全局作用域和函数作用域的概念，加之var声名变量和函数的变量提升，因而会出现同名变量覆盖和变量污染的问题。

ES6之后，出现了块级作用域的概念，即{}包裹的部分。同时出现了使用let const关键字，定义变量。

那么通过var和let定义的变量，在执行上下文方面，有什么不同呢？

看这样一段代码，当刚开始执行到块级作用域{}内部时，执行上下文如下

```javascript
function foo(){
    var a = 1
    let b = 2
    {
      let b = 3
      var c = 4
      let d = 5
      console.log(a)
      console.log(b)
    }
    console.log(b) 
    console.log(c)
    console.log(d)
}   
foo()
```

![](\picture\let-const.png)

- 函数内部通过 var 声明的变量，在编译阶段全都被存放到**变量环境**里面了。
- 通过 let 声明的变量，在编译阶段会被存放到**词法环境（Lexical Environment）**中
- let和const声名的变量，在不同的作用域内，也会按照栈结构进行存储。即词法环境的栈结构是用来管理let和const的执行上下文。
- 当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出
- let，也有变变量提升作用，但是只是在作用域块中提升，并且如果未赋值引用的话，会报错。注意区别于var未赋值引用的区别，var会为undefined。
- const定义变量时必须赋初始值。

#### 10 | 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？

```javascript
function bar() {
    console.log(myName)
}
function foo() {
    var myName = " 极客邦 "
    bar()
}
var myName = " 极客时间 "
foo()
```

当这段代码执行到 bar 函数内部时，其调用栈的状态图如下所示：

![](C:\Users\Administrator\Desktop\知识积累\picture\第十节课.png)

当执行bar函数时，会首先在bar函数上下文中寻找myName变量，发现没有，此时会按照作用域链，即这个函数内部的outer指向的执行上下文寻找变量。所以答案是 "极客时间"

![](\picture\第十节作用域链.png)

​	// 变量查找的链条就称为作用域链

​    // 在 JavaScript 执行过程中，其作用域链是由词法作用域决定的

##### 词法作用域

词法作用域就是指 作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

​    // 词法作用域就是指作用域是由代码中函数声明的位置来决定的，和函数是怎么调用的没有关系！！

​    // 在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。

​    // 如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找，即外部的函数执行上下文或全局执行上下文中查找。



下面这幅图的作用链，因为函数定义时是在函数内部定义的，所以作用域链是：

foo 函数作用域—>bar 函数作用域—>main 函数作用域—> 全局作用域。

![](\picture\词法作用域.png)

##### 闭包

**在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，外部函数的上下文已经出栈，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包**

比如一段代码：

```javascript
function foo() {
    var myName = " 极客时间 "
    let test1 = 1
    const test2 = 2
    var innerBar = {
        getName:function(){
            console.log(test1)
            return myName
        },
        setName:function(newName){
            myName = newName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName(" 极客邦 ")
bar.getName()
console.log(bar.getName())
```

当执行到foo函数的return是，上下文是这样的

![](\picture\return.png)

当执行完foo函数时，foo函数的执行上下文出栈。但是由于返回的内部函数引用了外部函数foo上下文中的变量myName和test1，所以这两个变量仍然会保存在内存中，称为foo函数的闭包。

![](\picture\foo闭包.png)

这个闭包内的变量，只能通过内部函数访问。

比如当执行setName访问访问myName变量时，访问顺序是： 当前函数setName上下文，foo的闭包，全局执行上下文。

思考题：

```javascript
var bar = {
    myName:"time.geekbang.com",
    printName: function () {
        console.log(myName)
    }    
}
function foo() {
    let myName = " 极客时间 "
    return bar.printName
}
let myName = " 极客邦 "
let _printName = foo()
_printName()
bar.printName()
```

这道题，不产生闭包。

因为foo函数执行，反回了内部函数printName，但是printName函数使用的变量myName是根据它的词法规则的作用域链决定的，printName函数上下文没有myName，所以去它的外部，即全局上下文中寻找myName，所以这里打印“极客帮”。注意printName函数的外部是全局，而不是bar对象，更不是foo函数上下文。所以foo函数执行完毕后，其上下文就出栈了，不产生引用foo的闭包。

bar 不是一个函数，同时内部没有变量提升，所以也没有上下文，bar 当中的 myName 只是对象的一个属性，也和 printName 没有联系，如果要产生联系，需要使用 this 关键字

即使直接调用bar.printName，打印的还是“极客帮”

对比这样一段代码：结果打印的是 “jike”。因为最外面大括号是一个块级作用域，有上下文和变量提升。这个块级作用域属于全局执行上下文的词法环境。根据作用域链链查找规则，会找到outer指向的上下文，其中含有提升的变量my。

```javascript
{
    let my = "jike"
    function foo(){
        console.log(my);
    }
    let you = "bang"
}
var my = "shijian"
foo() //能访问到foo因为只有let和const才能被提升到块级作用域顶，函数声名会被提升到函数作用域或全局作用域顶。
// console.log(you);访问不到
```







##### 闭包是怎么回收的



#### 11 | this：从JavaScript执行上下文的视角讲清楚this

基于上篇文章的思考题，最后的结果是两个“极客帮”，引发的思考。在 printName 函数里面使用的变量 myName 是属于全局作用域下面的，所以最终打印出来的值都是“极客邦”。这是因为 JavaScript 语言的作用域链是由词法作用域决定的，而词法作用域是由代码结构来确定的。

**对象内部的方法中使用对象内部的属性是一个非常普遍的需求**，基于这个需求，JavaScript 又搞出来另外一套**this 机制**。

**作用域链**和**this**是两套不同的系统，它们之间基本没太多联系。outer由词法作用域规定，与代码结构有关，在写出代码时已经规定好了，影响作用域链，即寻找变量的规则！！而this是为了解决作用域链查找变量时，有些不合理的地方。

##### this的产生

当编译阶段产生执行上下文时，除了变量环境，词法环境，指向外部的outer之外，还产生了this。**所以this是和执行上下文绑定的**，执行上下文分为全局执行上下文，函数执行上下文，eval执行上下文，同样，this也有这三种**全局执行上下文的this，函数执行上下文的this，eval执行上下文的this**

1. **全局执行上下文的this**：指向window

   直接在控制台输入console.log(this)

```javascript
console.log(this)  //window
```

​	这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。

2. **函数执行上下文的this**： 指向window

   来看下面四种情况，可以得出结论，函数执行上下文的this就是指向window，不论执行上下文的outer指向的是外部的函数执行上下文或者是全局执行上下文。**也就是作用域链outer和this指向完全没有关系**！！！

```javascript
function foo(){
  console.log(this) //window。
}
foo() 
```

```javascript
{
    let my = "jike"
    function foo(){
        console.log(my);
        console.log(this); //window。本例是上节思考题。
    }
    let you = "bang"
}
var my = "shijian"
foo()
```

```javascript
function outerfn(){
    return function(){
        console.log(this) //window  外部函数作用域是outerfn，但是this还是window
    }
}
outerfn()()
```

```javascript
function outerfn(){
    function a(){
        console.log(this) //window  外部函数作用域是outerfn，但是this还是window
    }
    a()
}
outerfn()
```

##### 如何改变this的指向

1. 通过函数call方法。

   使其指向call方法的对象参数

   ```javascript
   let bar = {
     myName : " 极客邦 ",
     test1 : 1
   }
   function foo(){
     this.myName = " 极客时间 "
   }
   foo.call(bar)  //原本this指向window，通过call方法调用后，this指向了bar对象。这时打印bar会发现myName已经是"极客时间"了
   ```

2. 通过对象调用方法

   使其指向对象

   ```javascript
   var myObj = {
     name : " 极客时间 ", 
     showThis: function(){
       console.log(this)
     }
   }
   myObj.showThis() //原本指向window，通过对象调用，指向了myObj对象
   ```

   其实也可以这样认为：调用showThis方法时，执行了myObj.showThis.call(myObj)

   注意下面这样，上面的例子改写

   ```javascript
   var myObj = {
     name : " 极客时间 ",
     showThis: function(){
       this.name = " 极客邦 "
       console.log(this)
     }
   }
   var foo = myObj.showThis
   foo()  //指向window 其实可以看做是window.foo()，所以当然是window
   ```

   所以通过以上两个例子的对比，你可以得出下面这样两个结论：

   - 在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。
   - 通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。

3. 通过构造函数设置

   ```javascript
   function CreateObj(){
     this.name = " 极客时间 "
   }
   var myObj = new CreateObj()  //this指向了myObj
   ```

   实际上当new了一个构造函数后，JavaScript引擎其实执行了以下4个步骤

   1. 在内存中创建了一个新的空对象tempObj
   2. 执行CreatObj.call(tempObj)方法，这样在执行CreatObj函数创建上下文时，this就指向了tempObj方法
   3. 执行函数体内部的代码，this指向tempObj。
   4. 将tempObj赋值给myObj，并将myObj返回

##### this缺陷

1. 被嵌套的函数的this不会从外部函数继承

   ```javascript
   var myObj = {
     name : " 极客时间 ", 
     showThis: function(){
       console.log(this) //myObj  因为是myObj调用了showThis方法，改变了原本showThis方法的指向，所以指向myObj
       function bar()
         {
             console.log(this) //window  函数内部的this默认指向window
         }
       bar()
     }
   }
   myObj.showThis()
   ```

   解决方案1：

   - 用一个小技巧使得嵌套函数this能够继承

   ​       这样的做的本质其实是将this系统转化为了作用域链系统

   ```javascript
   var myObj = {
     name : " 极客时间 ", 
     showThis: function(){
       console.log(this) //myObj  myObj调用了showThis方法，指向myObj
       var _that = this //将this的指向保存给了_that，所以_that就指向myObj
       function bar()
         {
             console.log(_that) //myObj
             _that.name = "极客帮" //通过作用域链的方式，查找修改myObj的name属性
         }
       bar()
     }
   }
   myObj.showThis()
   ```

   来看下面小技巧的应用：

   原本这样是会报错的，因为匿名函数内function的执行上下文的this是指向window的，而window执行上下文没有name age sex属性。

   ```javascript
           let userInfo = {
               name:"jack.ma",
               age:13,
               sex:'male',
               updateInfo:function(){
                   // 模拟 xmlhttprequest 请求延时
                   setTimeout(function(){
                       this.name = "pony.ma"
                       this.age = 39
                       this.sex = 'female'
                   },100)
               }
           }
           userInfo.updateInfo()
           console.log(userInfo);
   ```

   使用小技巧   

   ```javascript
           let userInfo = {
               name:"jack.ma",
               age:13,
               sex:'male',
               updateInfo:function(){
                   // 模拟 xmlhttprequest 请求延时
                   var _that = this
                   setTimeout(function(){
                       this.name = "pony.ma"
                       this.age = 39
                       this.sex = 'female'
                   }.call(_that),100)  //使匿名函数function内this指向改变成了_that，也就是this，也就是userInfo对象
               }
           }
           userInfo.updateInfo()
           console.log(userInfo);
   ```

   

   

   解决方案2：

   - 使用箭头函数

     箭头函数**不产生自己的执行上下文**，所以它自己没有this，所以箭头函数内部的this和箭头函数外面的this是一个

   ```javascript
   var myObj = {
     name : " 极客时间 ", 
     showThis: function(){
       console.log(this) //myObj
       var bar = ()=>{
         this.name = " 极客邦 "
         console.log(this)  //和上面的this是一个，所以仍是myObj
       }
       bar()
     }
   }
   myObj.showThis()
   console.log(myObj.name)
   console.log(window.name)
   ```

2. 函数内部的this默认都指向window

   解决方案：

   - 使用严格模式

     严格模式下，函数的this都指向undefined，可以通过call方法约束this指向的对象

     

##### 总结起来一句话

有执行上下文就有this，this默认指向window



#### 12 | 栈空间和堆空间：数据是如何存储的？

**静态语言**：在使用之前就必须确定其数据类型的语言。比如C语言

**动态语言**：运行过程中需要检查数据类型的语言，数据在声名前不用确认其类型。比如JavaScript

**隐式类型转换**：赋值过程中，把一种类型的变量赋给另一种原来是其他类型的变量，使得后者自动转化为前面的类型

**强类型语言**：不支持隐式类型转换

**弱类型语言**：支持隐式类型转换。  C，JavaScript









#### 22 | DOM树：JavaScript是如何影响DOM树构建的？

##### 什么是DOM？

从网络进程传给渲染引擎的HTML文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是DOM。

##### DOM三个作用

1. 页面角度，DOM是生成页面的基础数据结构。
2. JS角度，DOM提供了JS脚本操作的接口，可以对DOM结构访问，从而修改文档的结构、样式和内容。
3. 安全角度，DOM解析阶段将不安全的内容拒之门外。

##### DOM树如何生成？

将网络进程，传到渲染进程的文件字节流数据，通过HTML解析器解析成DOM树。这个过程是边加载边解析的。

具体：

1. 通过分词器将字节流转化为token。

   token分为tagtoken和文本token，tagtoken又分为starttag和endtag。

2. 将token转化为DOM节点，并将DOM节点添加到DOM树中。

3. 将tagtoken按顺序压入到栈中，遇到一对starttag、endtag则出栈，直至栈内容清空，判断DOM结构解析完毕。文本token不入栈。

##### JS和CSS如何影响DOM生成

JS文件在下载和解析的时候，因为可能会修改DOM树结构，所以会暂时挂起渲染引擎解析生成DOM树。这就是JS文件下载阻塞DOM解析。

JS文件也可能操作DOM的CSS样式，所以渲染引擎在遇到JS文件时，会先执行CSS文件下载，解析，再执行JS脚本。这又是一个阻塞DOM解析。

解决措施：

1. Chrome浏览器预解析，如果HTML文件中包含外部的JS文件、CSS文件，提前下载这些文件。
2. 使用CDN加速文件下载速度。
3. 压缩JS文件体积。
4. 如果JS文件中没有操作DOM的相关代码，可通过async或defer将脚本设置为异步加载。



#### 23 |渲染流水线：CSS如何影响首次加载时的白屏时间？

##### 影响页面展示的因素以及优化策略

##### 解析白屏

提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为**解析白屏**，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。

解析白屏阶段的主要任务：

包括了解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作。

其中白屏时间的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。

所以要想缩短白屏时长，可以有以下策略：

- 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
- 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。
- 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。
- 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。