### 浏览器工作原理

#### 01丨Chrome架构：仅仅打开了1个页面，为什么有4个进程？

##### 进程与线程

进程： 进程就是一个程序的运行实例。启动一个程序的时候，系统会为这个程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样一个环境叫做进程。

进程可以由多个线程构成，可以提高处理性能。线程不能单独存在，必须依附于进程。

线程和进程具有如下4个特点：

1. 进程中任意一线程执行出错，会导致整个进程崩溃。
2. 线程之间共享进程中的数据。
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。
4. 进程之间的内容相互隔离。

##### 早期的单进程浏览器时代

![](picture\单进程浏览器.png)

单进程浏览器：即浏览器的所有功能模块都运行在一个进程里。包括网络、插件、JS运行环境、渲染引擎、页面等模块。

特点：不稳定、不流畅和不安全

##### 多进程浏览器时代

![](picture\多进程浏览器.png)

![](picture\最新的多进程浏览器.png)

包括 1个浏览器主进程、1个网络进程、1个GPU进程、多个渲染进程、多个插件进程。

- **浏览器进程**。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。

- **渲染进程**。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。详见[浏览器渲染过程](https://blog.csdn.net/saucxs/article/details/87869810) *注 css资源  图片资源 js资源是在浏览器主进程中下载的*

  渲染进程包括如下几个线程：

  1、GUI渲染线程

  （1）负责解析HTML文件构建DOM树，解析CSS，结合DOM树渲染成RenderObject树，然后布局和绘制页面

  （2）当RenderObject树需要更新样式属性时，即发生重绘（Repaint）；当RenderObject树中的元素规则尺寸，布局或显示隐藏等发生变化，即发生回流（reflow）。

  2、JS引擎线程

  3、时间出发线程

  4、定时器触发线程

  5、异步Http请求线程

  注：GUI渲染线程与JS引擎线程是相互排斥的，因为JS引擎线程在执行的过程中可能会发生重绘和回流，所以GUI渲染线程执行时候，JS引擎线程会被挂起，等待GUI渲染线程执行完毕之后，JS引擎线程执行时候同理。

- **GPU 进程** 将图块栅格化生成位图

- **网络进程**。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。

- **插件进程**。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

特点：更高的资源占用、更复杂的体系架构

##### 未来的 面向服务的架构

![](picture\面向服务的架构.png)











#### 05丨渲染流程

1. 构建DOM树

   将HTML解析成浏览器能够识别的DOM树

2. 样式计算 CSSOM树

   作用：第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息

   目的：计算DOM树中每个元素的样式

   1. 把CSS文件转换为浏览器能够识别的样式表结构styleSheets
   2. 样式表中的属性值标准化，易于渲染引擎理解
   3. 根据CSS继承和层叠规则，计算DOM树中每个节点的具体样式

3. 布局阶段 布局树

   目的：过滤掉DOM树中不需要显示的元素，计算DOM树中可见元素的位置信息

   1. 创建布局树。根据DOM树和computedStyle生成只包含可见元素的布局树
   2. 布局计算。 计算每个可见节点的位置坐标

4. 分层

   为特定的节点生成专用的图层，进而生成一个图层树

   - 拥有层叠上下文属性的元素会被提升为单独的一层。如z-index:2, position:fixed, filter:blue(5px),opacity:0.5
   - 需要剪裁（clip）的地方也会被创建为图层。overflow:auto

   目的： 为了方便实现复杂的动画效果，如滚动，3D变换，Z轴排序

5. 生成绘制列表

   把每个图层的绘制拆分成很多小的绘制指令，组成待绘制列表

6. 栅格化操作

   实际的绘制操作是由渲染引擎的 合成线程 操作完成的。

   合成线程会将图层划分为图块。然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。

7. 合成和显示

   图块光栅化后，合成线程发出绘制图块命令，提交到浏览器进程，绘制到内存中，显示到屏幕上。

总结：

![](picture\渲染流程.png)

结合上图，一个完整的渲染流程大致可总结为如下：

1. 渲染进程将 HTML 内容转换为能够读懂的**DOM 树**结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的**styleSheets**，计算出 DOM 节点的样式。
3. 创建**布局树**，并计算元素的布局信息。
4. 对布局树进行分层，并生成**分层树**。
5. 为每个图层生成**绘制列表**，并将其提交到合成线程。
6. 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图。
7. 合成线程发送绘制图块命令**DrawQuad**给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息**生成页面**，并**显示**到显示器上。



#### 07 | 变量提升：JavaScript代码是按顺序执行的吗？

![](\picture\变量环境对象.png)

**所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined**

```javascript
showName()
console.log(myname)
var myname = '极客时间'
function showName() {
    console.log('函数 showName 被执行');
}

//结果是
'函数 showName 被执行'   //因为function showName 这是一个函数声名，整体都会提前。注意function(){}这个不是函数声名。
undefined	// var myname属于变量声名，但是赋值操作没有提升。
```

**实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中**。

**编译**完成之后，才会进入**执行**阶段。

输入一段代码，经过**编译**后，会生成两部分内容：**执行上下文（Execution context）和 可执行代码**。

**执行上下文是 JavaScript 执行一段代码时的运行环境**，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。在执行上下文中存在一个**变量环境的对象**（Viriable Environment），该对象中保存了变量提升的内容

变量环境对象：编译阶段变量提升的内容

```javascript
VariableEnvironment:
     myname -> undefined, 
     showName ->function : {console.log(myname)
```

JavaScript 引擎会把声明以外的代码编译为字节码



**一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数**。





#### 08 | 调用栈：为什么JavaScript代码会出现栈溢出？

执行代码执行过程中，遇到调用函数，会为该函数创建 函数执行上下文和执行代码

**调用栈是 JavaScript 引擎追踪函数执行的一个机制**，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。

JavaScript 引擎是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为**执行上下文栈**，又称**调用栈**。当遇到调用函数时，会将该函数的执行上下文压入栈中，执行函数的执行代码，如此直到栈空

所以，调用栈是一种用来管理执行上下文的数据结构



#### 22 | DOM树：JavaScript是如何影响DOM树构建的？

##### 什么是DOM？

从网络进程传给渲染引擎的HTML文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是DOM。

##### DOM三个作用

1. 页面角度，DOM是生成页面的基础数据结构。
2. JS角度，DOM提供了JS脚本操作的接口，可以对DOM结构访问，从而修改文档的结构、样式和内容。
3. 安全角度，DOM解析阶段将不安全的内容拒之门外。

##### DOM树如何生成？

将网络进程，传到渲染进程的文件字节流数据，通过HTML解析器解析成DOM树。这个过程是边加载边解析的。

具体：

1. 通过分词器将字节流转化为token。

   token分为tagtoken和文本token，tagtoken又分为starttag和endtag。

2. 将token转化为DOM节点，并将DOM节点添加到DOM树中。

3. 将tagtoken按顺序压入到栈中，遇到一对starttag、endtag则出栈，直至栈内容清空，判断DOM结构解析完毕。文本token不入栈。

##### JS和CSS如何影响DOM生成

JS文件在下载和解析的时候，因为可能会修改DOM树结构，所以会暂时挂起渲染引擎解析生成DOM树。这就是JS文件下载阻塞DOM解析。

JS文件也可能操作DOM的CSS样式，所以渲染引擎在遇到JS文件时，会先执行CSS文件下载，解析，再执行JS脚本。这又是一个阻塞DOM解析。

解决措施：

1. Chrome浏览器预解析，如果HTML文件中包含外部的JS文件、CSS文件，提前下载这些文件。
2. 使用CDN加速文件下载速度。
3. 压缩JS文件体积。
4. 如果JS文件中没有操作DOM的相关代码，可通过async或defer将脚本设置为异步加载。



#### 23 |渲染流水线：CSS如何影响首次加载时的白屏时间？

##### 影响页面展示的因素以及优化策略

##### 解析白屏

提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为**解析白屏**，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。

解析白屏阶段的主要任务：

包括了解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作。

其中白屏时间的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。

所以要想缩短白屏时长，可以有以下策略：

- 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
- 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。
- 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。
- 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。