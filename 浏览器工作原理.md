### 浏览器工作原理

#### 01丨Chrome架构：仅仅打开了1个页面，为什么有4个进程？

##### 进程与线程

进程： 进程就是一个程序的运行实例。启动一个程序的时候，系统会为这个程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样一个环境叫做进程。

进程可以由多个线程构成，可以提高处理性能。线程不能单独存在，必须依附于进程。

线程和进程具有如下4个特点：

1. 进程中任意一线程执行出错，会导致整个进程崩溃。
2. 线程之间共享进程中的数据。
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。
4. 进程之间的内容相互隔离。

##### 早期的单进程浏览器时代

![](picture\单进程浏览器.png)

单进程浏览器：即浏览器的所有功能模块都运行在一个进程里。包括网络、插件、JS运行环境、渲染引擎、页面等模块。

特点：不稳定、不流畅和不安全

##### 多进程浏览器时代

![](picture\多进程浏览器.png)

![](picture\最新的多进程浏览器.png)

包括 1个浏览器主进程、1个网络进程、1个GPU进程、多个渲染进程、多个插件进程。

- **浏览器进程**。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。

- **渲染进程**。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。详见[浏览器渲染过程](https://blog.csdn.net/saucxs/article/details/87869810) *注 css资源  图片资源 js资源是在浏览器主进程中下载的*

  渲染进程包括如下几个线程：

  1、GUI渲染线程

  （1）负责解析HTML文件构建DOM树，解析CSS，结合DOM树渲染成RenderObject树，然后布局和绘制页面

  （2）当RenderObject树需要更新样式属性时，即发生重绘（Repaint）；当RenderObject树中的元素规则尺寸，布局或显示隐藏等发生变化，即发生回流（reflow）。

  2、JS引擎线程

  3、时间出发线程

  4、定时器触发线程

  5、异步Http请求线程

  注：GUI渲染线程与JS引擎线程是相互排斥的，因为JS引擎线程在执行的过程中可能会发生重绘和回流，所以GUI渲染线程执行时候，JS引擎线程会被挂起，等待GUI渲染线程执行完毕之后，JS引擎线程执行时候同理。

- **GPU 进程** 将图块栅格化生成位图

- **网络进程**。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。

- **插件进程**。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

特点：更高的资源占用、更复杂的体系架构

##### 未来的 面向服务的架构

![](picture\面向服务的架构.png)











#### 05丨渲染流程

1. 构建DOM树

   将HTML解析成浏览器能够识别的DOM树

2. 样式计算 CSSOM树

   作用：第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息

   目的：计算DOM树中每个元素的样式

   1. 把CSS文件转换为浏览器能够识别的样式表结构styleSheets
   2. 样式表中的属性值标准化，易于渲染引擎理解
   3. 根据CSS继承和层叠规则，计算DOM树中每个节点的具体样式

3. 布局阶段 布局树

   目的：过滤掉DOM树中不需要显示的元素，计算DOM树中可见元素的位置信息

   1. 创建布局树。根据DOM树和computedStyle生成只包含可见元素的布局树
   2. 布局计算。 计算每个可见节点的位置坐标

4. 分层

   为特定的节点生成专用的图层，进而生成一个图层树

   - 拥有层叠上下文属性的元素会被提升为单独的一层。如z-index:2, position:fixed, filter:blue(5px),opacity:0.5
   - 需要剪裁（clip）的地方也会被创建为图层。overflow:auto

   目的： 为了方便实现复杂的动画效果，如滚动，3D变换，Z轴排序

5. 生成绘制列表

   把每个图层的绘制拆分成很多小的绘制指令，组成待绘制列表

6. 栅格化操作

   实际的绘制操作是由渲染引擎的 合成线程 操作完成的。

   合成线程会将图层划分为图块。然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。

7. 合成和显示

   图块光栅化后，合成线程发出绘制图块命令，提交到浏览器进程，绘制到内存中，显示到屏幕上。

总结：

![](picture\渲染流程.png)

结合上图，一个完整的渲染流程大致可总结为如下：

1. 渲染进程将 HTML 内容转换为能够读懂的**DOM 树**结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的**styleSheets**，计算出 DOM 节点的样式。
3. 创建**布局树**，并计算元素的布局信息。
4. 对布局树进行分层，并生成**分层树**。
5. 为每个图层生成**绘制列表**，并将其提交到合成线程。
6. 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图。
7. 合成线程发送绘制图块命令**DrawQuad**给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息**生成页面**，并**显示**到显示器上。



#### 07 | 变量提升：JavaScript代码是按顺序执行的吗？

![](\picture\变量环境对象.png)

**所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined**

```javascript
showName()
console.log(myname)
var myname = '极客时间'
function showName() {
    console.log('函数 showName 被执行');
}

//结果是
'函数 showName 被执行'   //因为function showName 这是一个函数声名，整体都会提前。注意function(){}这个不是函数声名。
undefined	// var myname属于变量声名，但是赋值操作没有提升。
```

**实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中**。

**编译**完成之后，才会进入**执行**阶段。

输入一段代码，经过**编译**后，会生成两部分内容：**执行上下文（Execution context）和 可执行代码**。

**执行上下文是 JavaScript 执行一段代码时的运行环境**，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。在执行上下文中存在一个**变量环境的对象**（Viriable Environment），该对象中保存了变量提升的内容

变量环境对象：编译阶段变量提升的内容

```javascript
VariableEnvironment:
     myname -> undefined, 
     showName ->function : {console.log(myname)
```

JavaScript 引擎会把声明以外的代码编译为字节码



**一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数**。





#### 08 | 调用栈：为什么JavaScript代码会出现栈溢出？

执行代码执行过程中，遇到调用函数，会为该函数创建 函数执行上下文和执行代码

**调用栈是 JavaScript 引擎追踪函数执行的一个机制**，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。

JavaScript 引擎是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为**执行上下文栈**，又称**调用栈**。当遇到调用函数时，会将该函数的执行上下文压入栈中，执行函数的执行代码，如此直到栈空

所以，调用栈是一种用来管理执行上下文的数据结构



#### 09 | 块级作用域：var缺陷以及为什么要引入let和const？

ES6之前，只存在全局作用域和函数作用域的概念，加之var声名变量和函数的变量提升，因而会出现同名变量覆盖和变量污染的问题。

ES6之后，出现了块级作用域的概念，即{}包裹的部分。同时出现了使用let const关键字，定义变量。

那么通过var和let定义的变量，在执行上下文方面，有什么不同呢？

看这样一段代码，当刚开始执行到块级作用域{}内部时，执行上下文如下

```javascript
function foo(){
    var a = 1
    let b = 2
    {
      let b = 3
      var c = 4
      let d = 5
      console.log(a)
      console.log(b)
    }
    console.log(b) 
    console.log(c)
    console.log(d)
}   
foo()
```

![](\picture\let-const.png)

- 函数内部通过 var 声明的变量，在编译阶段全都被存放到**变量环境**里面了。
- 通过 let 声明的变量，在编译阶段会被存放到**词法环境（Lexical Environment）**中
- let和const声名的变量，在不同的作用域内，也会按照栈结构进行存储。即词法环境的栈结构是用来管理let和const的执行上下文。
- 当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出
- let，也有变变量提升作用，但是只是在作用域块中提升，并且如果未赋值引用的话，会报错。注意区别于var未赋值引用的区别，var会为undefined。
- const定义变量时必须赋初始值。

#### 10 | 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？

```javascript
function bar() {
    console.log(myName)
}
function foo() {
    var myName = " 极客邦 "
    bar()
}
var myName = " 极客时间 "
foo()
```

当这段代码执行到 bar 函数内部时，其调用栈的状态图如下所示：

![](C:\Users\Administrator\Desktop\知识积累\picture\第十节课.png)

当执行bar函数时，会首先在bar函数上下文中寻找myName变量，发现没有，此时会按照作用域链，即这个函数内部的outer指向的执行上下文寻找变量。所以答案是 "极客时间"

![](C:\Users\Administrator\Desktop\知识积累\picture\第十节作用域链.png)

​	// 变量查找的链条就称为作用域链

​    // 在 JavaScript 执行过程中，其作用域链是由词法作用域决定的

##### 词法作用域

词法作用域就是指 作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

​    // 词法作用域就是指作用域是由代码中函数声明的位置来决定的，和函数是怎么调用的没有关系！！

​    // 在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。

​    // 如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找



下面这幅图的作用链，因为函数定义时是在函数内部定义的，所以作用域链是：

foo 函数作用域—>bar 函数作用域—>main 函数作用域—> 全局作用域。

![](C:\Users\Administrator\Desktop\知识积累\picture\词法作用域.png)

##### 闭包

**在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，外部函数的上下文已经出栈，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包**

比如一段代码：

```javascript
function foo() {
    var myName = " 极客时间 "
    let test1 = 1
    const test2 = 2
    var innerBar = {
        getName:function(){
            console.log(test1)
            return myName
        },
        setName:function(newName){
            myName = newName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName(" 极客邦 ")
bar.getName()
console.log(bar.getName())
```

当执行到foo函数的return是，上下文是这样的

![](C:\Users\Administrator\Desktop\知识积累\picture\return.png)

当执行完foo函数时，foo函数的执行上下文出栈。但是由于返回的内部函数引用了外部函数foo上下文中的变量myName和test1，所以这两个变量仍然会保存在内存中，称为foo函数的闭包。

![](C:\Users\Administrator\Desktop\知识积累\picture\foo闭包.png)

这个闭包内的变量，只能通过内部函数访问。

比如当执行setName访问访问myName变量时，访问顺序是： 当前函数setName上下文，foo的闭包，全局执行上下文。

思考题：

```javascript
var bar = {
    myName:"time.geekbang.com",
    printName: function () {
        console.log(myName)
    }    
}
function foo() {
    let myName = " 极客时间 "
    return bar.printName
}
let myName = " 极客邦 "
let _printName = foo()
_printName()
bar.printName()
```

这道题，不产生闭包。

因为foo函数执行，反回了内部函数printName，但是printName函数使用的变量myName是根据它的词法规则的作用域链决定的，printName函数上下文没有myName，所以去它的外部，即全局上下文中寻找myName，所以这里打印“极客帮”。注意printName函数的外部是全局，而不是bar对象，更不是foo函数上下文。所以foo函数执行完毕后，其上下文就出栈了，不产生引用foo的闭包。

bar 不是一个函数，内部没有变量提升，所以也没有上下文，bar 当中的 myName 只是对象的一个属性，也和 printName 没有联系，如果要产生联系，需要使用 this 关键字

即使直接调用bar.printName，打印的还是“极客帮”





##### 闭包是怎么回收的







#### 22 | DOM树：JavaScript是如何影响DOM树构建的？

##### 什么是DOM？

从网络进程传给渲染引擎的HTML文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是DOM。

##### DOM三个作用

1. 页面角度，DOM是生成页面的基础数据结构。
2. JS角度，DOM提供了JS脚本操作的接口，可以对DOM结构访问，从而修改文档的结构、样式和内容。
3. 安全角度，DOM解析阶段将不安全的内容拒之门外。

##### DOM树如何生成？

将网络进程，传到渲染进程的文件字节流数据，通过HTML解析器解析成DOM树。这个过程是边加载边解析的。

具体：

1. 通过分词器将字节流转化为token。

   token分为tagtoken和文本token，tagtoken又分为starttag和endtag。

2. 将token转化为DOM节点，并将DOM节点添加到DOM树中。

3. 将tagtoken按顺序压入到栈中，遇到一对starttag、endtag则出栈，直至栈内容清空，判断DOM结构解析完毕。文本token不入栈。

##### JS和CSS如何影响DOM生成

JS文件在下载和解析的时候，因为可能会修改DOM树结构，所以会暂时挂起渲染引擎解析生成DOM树。这就是JS文件下载阻塞DOM解析。

JS文件也可能操作DOM的CSS样式，所以渲染引擎在遇到JS文件时，会先执行CSS文件下载，解析，再执行JS脚本。这又是一个阻塞DOM解析。

解决措施：

1. Chrome浏览器预解析，如果HTML文件中包含外部的JS文件、CSS文件，提前下载这些文件。
2. 使用CDN加速文件下载速度。
3. 压缩JS文件体积。
4. 如果JS文件中没有操作DOM的相关代码，可通过async或defer将脚本设置为异步加载。



#### 23 |渲染流水线：CSS如何影响首次加载时的白屏时间？

##### 影响页面展示的因素以及优化策略

##### 解析白屏

提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为**解析白屏**，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。

解析白屏阶段的主要任务：

包括了解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作。

其中白屏时间的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。

所以要想缩短白屏时长，可以有以下策略：

- 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
- 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。
- 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。
- 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。